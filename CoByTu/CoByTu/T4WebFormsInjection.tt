<#
/*
T4WebFormsInjection Version 2.0.1

T4WebFormsInjection generates parameterless constructors for classes that extend the types in the IncludedTypes setting.

The intent is to allow for dependency injection in the subclasses asp.net types that are constructed via a factory. 
These include:
        - System.Web.UI.MasterPage
        - System.Web.UI.Pages
        - System.Web.UI.UserControls
        - System.Web.IHttpHandler
        - System.Web.IHttpModule
		- System.Web.Services.WebService

Settings code has been harvested from T4MVC MvcSettings (https://github.com/T4MVC/T4MVC) [Licence: Apache 2.0]
Manager.tt from Damien Guard: http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited

*/
#>
<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".generated.cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#
    var modelData = PrepareDataToRender(this, Host);
    var manager = Manager.Create(Host, GenerationEnvironment);
#>
<#    manager.StartHeader(); #>
// <autogenerated>
//   Do not modify this file manually. Any changes will be lost next time the code is regenerated.
// </autogenerated>

<#    manager.EndBlock(); #>
<# if (settings.OutputRegistrationList || modelData.TrackObjectsForDisposal)
{ #>
namespace <#= modelData.Namespace #>
{
<# if (settings.OutputRegistrationList) { #>
	using System;
<# } #>
	using System.Collections.Generic;
<# if (modelData.TrackObjectsForDisposal) { #>
	using System.Runtime.CompilerServices;
<# } #>

<# if (settings.IncludeDocumentation)
{ #>
	/// <summary>
	///	All types registered for injection by T4WebFormsInjection.
	/// </summary>
	/// <remarks>
	/// Registered classes can be checked against IOC framework for correct registration.
	/// </remarks>
<# } #>
	public static class T4WebFormsInjection
	{
<# if (settings.OutputRegistrationList) 
	{
		if (settings.IncludeDocumentation)
		{ #>
		/// <summary>
		///	Get all types registered for injection by T4WebFormsInjection.
		/// </summary>
		/// <returns>
		/// All types registered for injection by T4WebFormsInjection.
		/// </returns>
<# } #>
		public static IEnumerable<Type> RegisteredTypes
		{
			get
			{
<# foreach (var type in modelData.RegisteredTypes) 
{#>
				yield return typeof(<#= type #>);
<# } #>
			}
		}

<# }
	if (modelData.TrackObjectsForDisposal) { #>
		internal static class DependencyManager
	    {
            private static ConditionalWeakTable<object, DependencyTracker> Tracker;

	        static DependencyManager()
	        {
                DependencyManager.Tracker = new ConditionalWeakTable<object, DependencyTracker>();
            }

	        public static void Track(object target, DependencyTracker dependencyTracker)
	        {
                DependencyManager.Tracker.Add(target, dependencyTracker);
	        }
	    }

        internal class DependencyTracker
        {
            private readonly List<object> trackedObjects;

	        internal DependencyTracker(int capacity = 1)
	        {
	            this.trackedObjects = new List<object>(capacity);
	        }

			internal T Add<T>(T o)
			{
				this.trackedObjects.Add(o);
				return o;
			}

	        internal void Release()
	        {
	            foreach (var trackedObject in this.trackedObjects)
	            {
					<#= string.Format(modelData.ContainerReleaseFormat, "trackedObject") #>;
	            }

				this.trackedObjects.Clear();
	        }

	        ~DependencyTracker()
	        {
	            this.Release();
	        }
	    }
<# } #>
	}
}

<# 
} #>
<#    manager.EndBlock(); #>
<#    foreach(var kv in modelData.Items) { #>
<# manager.StartNewFile(kv.Key + ".generated.cs"); #>
namespace <#= kv.Key #>
{
    using System;
<#
        foreach(var cd in kv.Value)
        {
#>

    public partial class <#= cd.Name #>
    {
<# if (settings.IncludeDocumentation)
{ #>
        /// <summary>
        /// Initializes a new instance of the <see cref="<#= cd.Name #>"/> class.
        /// </summary>
        /// <remarks>
        /// Generated by T4WebFormsInjected.
        /// </remarks>
<# } #>
<# if (modelData.TrackObjectsForDisposal) { #>
        [Obsolete("Use <#= cd.ConstructorSignature #> instead.")]
        public <#= cd.Name #>()
            : this(new <#= modelData.Namespace #>.T4WebFormsInjection.DependencyTracker(<#= cd.Parameters.Length #>))
        {
        }

		private <#= cd.Name #>(<#= modelData.Namespace #>.T4WebFormsInjection.DependencyTracker tracker)
			: this(<#= cd.ParameterSignature(22, "tracker.Add({0})") #>)
		{
			<#= modelData.Namespace #>.T4WebFormsInjection.DependencyManager.Track(this, tracker);
		}
<# } else { #>        [Obsolete("Use <#= cd.ConstructorSignature #> instead.")]
        public <#= cd.Name #>()
            : this(<#= cd.ParameterSignature(22) #>)
        {
        }
<# } #>
    }
<#
        }
#>}

<# manager.EndBlock(); #>
<#
    }
	settings.SaveChanges(manager); 
	manager.Process(settings.SplitIntoMultipleFiles);
#>
<#+
    static TextTransformation TT;
    static string T4FileName;
    static Settings settings;
    static Model model;

    Model.Data PrepareDataToRender(TextTransformation tt, ITextTemplatingEngineHost host)
    {
        TT = tt;
        T4FileName = Path.GetFileName(host.TemplateFile);
        settings = Settings.Load(Host);

        var visualStudio = (this.Host as IServiceProvider).GetService(typeof(DTE)) as DTE;
        var project = visualStudio.Solution.FindProjectItem(this.Host.TemplateFile)
            .ContainingProject as Project;

        model = new Model(project, settings.IncludedTypes.ToArray(), settings.ContainerConstructorFormat, settings.ContainerReleaseFormat);
        return model.Get();
    }

    public class Model
    {
        private readonly Project project;

        private readonly string[] baseClass;

        public readonly string DiConstructorFormat;
        
		public readonly string DiReleaseFormat;
		
		public readonly bool TrackObjectsForDisposal;

        public Model(Project project, string[] baseClass, string diConstructorFormat, string diReleaseFormat)
        {
            this.project = project;
            this.baseClass = baseClass;
            this.DiConstructorFormat = diConstructorFormat;
			this.DiReleaseFormat = diReleaseFormat;
			this.TrackObjectsForDisposal = !string.IsNullOrWhiteSpace(this.DiReleaseFormat);
        }

        private List<string> GetProjectNamespaces()
        {
            List<string> namespaces = new List<string>();
            foreach(EnvDTE.ProjectItem item in GetProjectItemsRecursively(this.project.ProjectItems))
            {
                if (item.FileCodeModel == null) 
                {
                    continue;
                }

                foreach(EnvDTE.CodeElement elem in item.FileCodeModel.CodeElements)
                {
                    if (elem.Kind == EnvDTE.vsCMElement.vsCMElementNamespace
                        && !namespaces.Contains(elem.FullName))
                    {
                        namespaces.Add(elem.FullName);
                    }
                }
            }

            return namespaces;
        }

        private IEnumerable<ProjectItem> GetProjectItemsRecursively(ProjectItems items)
        {
            var ret = new List<ProjectItem>();
            if (items == null) 
            {
                return ret;     
            }

            foreach(ProjectItem item in items)
            {
                ret.Add(item);
                ret.AddRange(GetProjectItemsRecursively(item.ProjectItems));
            }
            return ret;
        }

        private void RecurseNamespace(List<string> filter, List<ClassDetails> classes, IEnumerable<EnvDTE.CodeNamespace> namespaces)
        {
            foreach(var ns in namespaces)
            {
                this.RecurseNamespace(filter, classes, ns.Members.OfType<EnvDTE.CodeNamespace>().Where(cn => filter.Any(x => x.StartsWith(cn.FullName))));

                var items = ns.Members.OfType<EnvDTE80.CodeClass2>()
                    .Where(x => this.baseClass.Any(c => x.IsDerivedFrom[c]) || x.ImplementedInterfaces.Cast<CodeInterface>().Any(ci => this.baseClass.Any(c => ci.IsDerivedFrom[c])));
                
                foreach(var cc in items)
                {
                    foreach (var p in cc.Parts.OfType<CodeElement2>().Where(x => x.IsCodeType))
                    {
                        CodeType ct = (CodeType)p;

                        bool hasConstructor = ct.Members.OfType<EnvDTE.CodeFunction>()
                            .Any(x => (x.Name == ct.Name) 
                            && (x.Access == vsCMAccess.vsCMAccessPublic) 
                            && (x.Parameters.Count > 0));

                        if (hasConstructor)
                        {
                            if (cc.ClassKind != vsCMClassKind.vsCMClassKindPartialClass)
                            {
                                try
                                {
                                    cc.ClassKind = vsCMClassKind.vsCMClassKindPartialClass;
                                    TT.Warning(string.Format("{0} changed the class {1} to be partial", T4FileName, cc.FullName));
                                }
                                catch
                                {
                                    // If we couldn't make it partial, give a warning and skip it
                                    TT.Error(string.Format("{0} was not able to make the class {1} partial. Please change it manually if possible", T4FileName, cc.FullName));
                                }
                            }

                            var q = ct.Members.OfType<EnvDTE.CodeFunction>()
                                    .Where(x => (x.Name == ct.Name) && (x.Access == vsCMAccess.vsCMAccessPublic))
                                    .OrderByDescending(x => x.Parameters.Count);

                            ClassDetails details = new ClassDetails(this)
                                {
                                    Namespace = ns.FullName,
                                    Name = ct.Name,
                                    Parameters = q.First().Parameters.OfType<CodeParameter>().Select(x => new Parameter
                                    {
                                        Name = x.Name,
                                        Type = x.Type.AsFullName
                                        }).ToArray()
                                    };

                            classes.Add(details);
                        }
                    }
                }
            }
        }

        public Data Get()
        {
            List<string> namespaces = this.GetProjectNamespaces();

            var codeNamespaces = project.CodeModel.CodeElements
                .OfType<EnvDTE.CodeNamespace>()
                .Where(cn => namespaces.Any(x => x.StartsWith(cn.FullName)));

            var classes = new List<ClassDetails>();

            this.RecurseNamespace(namespaces, classes, codeNamespaces);

            this.ShowDuplicateConstructorWarning(classes);

            var q = from n in classes
		            group n by n.Namespace into g
		            orderby g.Key
		            select new {
			            Namespace = g.Key,
			            Classes = from i in g
					              group i by i.Name into k
					              orderby k.Key
					              select k.OrderByDescending(x => x.Parameters.Count()).First()
		            };

            return new Data
            {
				Namespace = project.Properties.Item("DefaultNamespace").Value.ToString(),
				ContainerReleaseFormat = DiReleaseFormat,
				TrackObjectsForDisposal = TrackObjectsForDisposal,
                Items = q.ToDictionary(k => k.Namespace, v => v.Classes.ToArray()),
				RegisteredTypes = classes.SelectMany(x => x.Parameters).Select(x => x.Type).Distinct().OrderBy(x => x)
            };
        }

        private void ShowDuplicateConstructorWarning(IEnumerable<ClassDetails> classes)
        {
            var q = from c in classes
                    group c by new { c.Namespace, c.Name } into g
		            where g.Count() > 1
		            select new {
			            g.Key.Namespace,
			            g.Key.Name,
                        Count = g.Count()
		            };

            foreach (var d in q)
            {
                TT.Warning(string.Format("{0} found {1} injectable constructors for '{2}.{3}'", T4FileName, d.Count, d.Namespace, d.Name));
            }
        }

        public class Data
        {
			public string Namespace { get; set; }

			public string ContainerReleaseFormat { get; set; }

			public bool TrackObjectsForDisposal { get; set; }

			public IEnumerable<string> RegisteredTypes { get; set; }

            public Dictionary<string, Model.ClassDetails[]> Items { get; set; }
        }

        public class ClassDetails
        {
            private readonly Model model;

            public ClassDetails(Model model)
            {
                this.model = model;
            }

            public string Namespace { get; set; }

            public string Name { get; set; }

            public Parameter[] Parameters { get; set; }

            public string ConstructorSignature
            {
                get
                {
                    return string.Format("{0}.{1}({2})", this.Namespace, this.Name, string.Join(", ", this.Parameters.Select(x => x.Name)));
                }
            }

            public string ParameterSignature(int indentationPadding, string format = "{0}")
            {
                string seperator = ",\r\n".PadRight(indentationPadding);

                return string.Join(seperator, this.Parameters.Select(x => string.Format("{0}: {1}", x.Name, string.Format(format, string.Format(this.model.DiConstructorFormat, x.Type)))));
            }
        }

        public class Parameter
        {
            public string Name { get; set; }
            public string Type { get; set; }
        }
    }

/*
    Settings shamelessly copied from T4MVC (MvcSettings): https://github.com/T4MVC
*/

    class Settings : XmlSettings
    {
        public static Settings Load(ITextTemplatingEngineHost host)
        {
            return Load<Settings>(host);
        }

        public Settings()
        {
            this.ContainerConstructorFormat = "Container.GetInstance<{0}>()";
			this.ContainerReleaseFormat = "Container.Release({0})";
            this.IncludedTypes = new XmlStringArray(new string[] {
                "System.Web.UI.MasterPage",
                "System.Web.UI.Page",
                "System.Web.UI.UserControl",
                "System.Web.IHttpHandler",
                "System.Web.IHttpModule",
                "System.Web.Services.WebService"
                }, "Type");
            this.SplitIntoMultipleFiles = false;
            this.IncludeDocumentation = false;
            this.OutputRegistrationList = false;
        }

        [System.ComponentModel.Description("String to format with the type to be instantiated.")]
        public string ContainerConstructorFormat { get; set; }

        [System.ComponentModel.Description("String to format the release of an instantiated object. Leave empty if releasing the object is not required.")]
        public string ContainerReleaseFormat { get; set; }

        [System.ComponentModel.Description("Types to generate constructors for.")]
        public XmlStringArray IncludedTypes { get; set; }

        [System.ComponentModel.Description("If true, the template output will be split into multiple files.")]
        public bool SplitIntoMultipleFiles { get; set; }
        
        [System.ComponentModel.Description("If true, the template output will include documentation for the constructor.")]
        public bool IncludeDocumentation { get; set; }

        [System.ComponentModel.Description("If true, the template output will include a registration list of all items to be injected.")]
        public bool OutputRegistrationList { get; set; }
    }

/*
    XmlSettings base classes, if you need to modify the T4MVC properties edit the Settings Class Above
*/

    /// Base XmlSettings class, responsible for reading/writing the settigns file contents, all settings other 
    /// than string convertable types should decend from this class
    abstract class XmlSettingsBase
    {
        protected XmlSettingsBase()
        {
            this.NeedsSave = true;
        }

        protected virtual void Init()
        {
        }

        protected bool SaveAsChild { get; private set; }

        protected bool NeedsSave { get; private set; }

        protected static void SetSaveAsChild(XmlSettingsBase settings, bool value)
        {
            settings.SaveAsChild = value;
        }

        protected static void SetNeedsSave(XmlSettingsBase settings, bool value)
        {
            settings.NeedsSave = value;
        }

        protected static void WriteCommentedProperty(System.Xml.XmlWriter writer, string name)
        {
            writer.WriteComment(string.Concat("<", name, "></", name, ">"));
        }

        protected static void WritePropertyDesc(System.Xml.XmlWriter writer, System.ComponentModel.PropertyDescriptor property)
        {
            var desc = property.Attributes.OfType<System.ComponentModel.DescriptionAttribute>().FirstOrDefault();
            if(desc != null)
            {
                writer.WriteComment(desc.Description);
            }
        }

        protected virtual void Load(System.Xml.Linq.XElement xml)
        {
            this.NeedsSave = false;
            int matched = 0;
            int read = 0;
            foreach(System.ComponentModel.PropertyDescriptor property in System.ComponentModel.TypeDescriptor.GetProperties(this))
            {
                object pvalue;
                if(typeof(XmlSettingsBase).IsAssignableFrom(property.PropertyType) || (((pvalue = property.GetValue(this)) != null) && typeof(XmlSettingsBase).IsAssignableFrom(pvalue.GetType())))
                {
                    read++;
                    var value = xml.Element(property.Name);
                    if(value != null)
                    {
                        var settings = (XmlSettingsBase)property.GetValue(this);
                        settings.Load(value);
                        if(!settings.NeedsSave)
                            matched++;
                        settings.SaveAsChild = true;
                    }
                }
                else if(!property.IsReadOnly)
                {
                    read++;
                    var value = xml.Element(property.Name);
                    if(value != null)
                    {
                        if(property.Converter.CanConvertFrom(typeof(string)))
                        {
                            matched++;
                            property.SetValue(this, property.Converter.ConvertFromString(value.Value));
                        }
                        else
                        {
                            System.Reflection.MethodBase parser = property.PropertyType.GetMethod("Parse", new Type[] { typeof(string) });
                            if(parser == null)
                                parser = property.PropertyType.GetConstructor(new Type[] { typeof(string) });

                            if(parser != null)
                            {
                                matched++;
                                property.SetValue(this, parser.Invoke(null, new Object[] { value.Value }));
                            }
                        }
                    }
                }
            }
            this.NeedsSave = this.NeedsSave || (matched < read);
        }

        protected virtual void Save(System.Xml.XmlWriter writer)
        {
            foreach(System.ComponentModel.PropertyDescriptor property in System.ComponentModel.TypeDescriptor.GetProperties(this))
            {
                var value = property.GetValue(this);
                WritePropertyDesc(writer, property);
                if(value != null)
                {
                    if(typeof(XmlSettingsBase).IsAssignableFrom(value.GetType()))
                    {
                        var settings = (XmlSettingsBase)property.GetValue(this);
                        if((settings != null) && settings.SaveAsChild)
                        {
                            writer.WriteStartElement(property.Name);
                            settings.Save(writer);
                            writer.WriteEndElement();
                        }
                    } else if(!property.IsReadOnly)
                    {
                        writer.WriteElementString(property.Name, property.Converter.ConvertToString(value));
                    }
                }
                else
                {
                    WriteCommentedProperty(writer, property.Name);
                }
            }
        }
    }

    /// Custom class to allow string arrays to be read and written to/from settings
    class XmlStringArray : XmlSettingsBase, IEnumerable<string>
    {
        public XmlStringArray(IEnumerable<string> items, string name)
        {
            this._items = items;
            this._name = name;
            SetSaveAsChild(this, true);
        }

        string _name;
        IEnumerable<string> _items;

        protected override void Load(System.Xml.Linq.XElement xml)
        {
            var items = new List<string>();
            foreach(var item in xml.Elements(this._name))
            {
                items.Add(item.Value);
            }
            this._items = items;
            SetNeedsSave(this, false);
        }

        protected override void Save(System.Xml.XmlWriter writer)
        {
            if(this._items == null || !this._items.Any())
            {
                WriteCommentedProperty(writer, this._name);
                return;
            }

            foreach(var item in this._items)
            {
                writer.WriteElementString(this._name, item);
            }
        }

        public IEnumerator<string> GetEnumerator()
        {
            return this._items.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }

    /// This is the base class for the standard settings, the main settigns class should inherit from this
    /// one since it provides the methods to interact with the T4 system and EnvDTE. Sub-properties can
    /// just inherit from XmlSettingsBase.
    abstract class XmlSettings : XmlSettingsBase
    {
        protected static T Load<T>(ITextTemplatingEngineHost host) where T : XmlSettings, new()
        {
            T settings = new T();
            settings.Init(host);
            return settings;
        }

        void Init(ITextTemplatingEngineHost host)
        {

            this.TemplateFile = Path.GetFileName(host.TemplateFile);
            this.TemplateFolder = Path.GetDirectoryName(host.TemplateFile);

            // Get the DTE service from the host
            var serviceProvider = host as IServiceProvider;
            if (serviceProvider != null)
            {
                this.DTE = (EnvDTE.DTE)serviceProvider.GetService(typeof(EnvDTE.DTE));
            }

            // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
            if (this.DTE == null)
            {
                throw new Exception("T4Build can only execute through the Visual Studio host");
            }

            this.ProjectItem = this.DTE.Solution.FindProjectItem(host.TemplateFile);

            // If the .tt file is not opened, open it
            if (this.ProjectItem.Document == null)
                this.ProjectItem.Open(EnvDTE.Constants.vsViewKindCode);

            this.Project = this.ProjectItem.ContainingProject;

            if (Project == null)
            {
                throw new Exception("Could not find the VS Project containing the T4 file.");
            }

            this.Load();
            this.Init();
        }

        public string TemplateFile { get; private set; }

        public string TemplateFolder { get; private set; }

        public DTE DTE { get; private set; }

        public ProjectItem ProjectItem { get; private set; }

        public Project Project { get; private set; }

        ProjectItem FindProjectItemRecursive(ProjectItems items, string name)
        {
            if(items == null)
                return null;

            foreach(ProjectItem item in items)
            {
                if(item.Name.Equals(name) || item.Name.StartsWith(name + "."))
                    return item;
                var found = FindProjectItemRecursive(item.ProjectItems, name);
                if(found != null)
                    return found;
            }

            return null;
        }

        protected ProjectItem FindProjectItem(string name)
        {
            return this.FindProjectItemRecursive(this.Project.ProjectItems, name);
        }

        protected string SettingsFile
        {
            get
            {
                return Path.Combine(this.TemplateFolder, string.Concat(this.TemplateFile, ".settings.xml"));
            }
        }

        void Load()
        {
            if(System.IO.File.Exists(this.SettingsFile))
                try
                {
                    this.Load(System.Xml.Linq.XElement.Load(this.SettingsFile));
                } catch { throw; }
        }

        public void SaveChanges(Manager manager)
        {
            // Avoid saving if we dont need to;
            if(!this.NeedsSave)
                return;

            if(manager.FileOkToWrite(this.SettingsFile))
            {
                var settings = new System.Xml.XmlWriterSettings
                    {
                        Indent = true
                        };
                using(var writer = System.Xml.XmlWriter.Create(this.SettingsFile, settings))
                {
                    writer.WriteStartDocument();
                    writer.WriteStartElement(this.GetType().Name);
                    this.Save(writer);
                    writer.WriteEndElement();
                    writer.WriteEndDocument();
                }

                var item = this.ProjectItem.Collection.AddFromFile(this.SettingsFile);
                item.Properties.Item("ItemType").Value = "None";
            } else
                TT.Error(string.Format("{0} cannot save settings file: {1}", T4FileName, this.SettingsFile));
        }
    }

/*
    End of T4MVC (MvcSettings): https://github.com/T4MVC
*/
/*
    Manager.tt from Damien Guard: http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
*/


// Manager class records the various blocks so it can split them up
    class Manager
    {
        private class Block
        {
            public String Name;
            public int Start, Length;
        }

        private Block currentBlock;
        private List<Block> files = new List<Block>();
        private Block footer = new Block();
        private Block header = new Block();
        private ITextTemplatingEngineHost host;
        private StringBuilder template;
        protected List<String> generatedFileNames = new List<String>();

        public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template)
        {
            return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
        }

        public virtual bool FileOkToWrite(String fileName)
        {
            return true;
        }

        public void KeepGeneratedFile(String name)
        {
            name = Path.Combine(Path.GetDirectoryName(host.TemplateFile), name);
            generatedFileNames.Add(name);
        }
    
        public void StartNewFile(String name)
        {
            if (name == null)
                throw new ArgumentNullException("name");
            CurrentBlock = new Block { Name = name };
        }

        public void StartFooter()
        {
            CurrentBlock = footer;
        }

        public void StartHeader()
        {
            CurrentBlock = header;
        }

        public void EndBlock()
        {
            if (CurrentBlock == null)
                return;
            CurrentBlock.Length = template.Length - CurrentBlock.Start;
            if (CurrentBlock != header && CurrentBlock != footer)
                files.Add(CurrentBlock);
            currentBlock = null;
        }

        public virtual void Process(bool split)
        {
            if (split)
            {
                EndBlock();
                String headerText = template.ToString(header.Start, header.Length);
                String footerText = template.ToString(footer.Start, footer.Length);
                String outputPath = Path.GetDirectoryName(host.TemplateFile);
                files.Reverse();
                foreach (Block block in files)
                {
                    String fileName = Path.Combine(outputPath, block.Name);
                    String content = headerText + template.ToString(block.Start, block.Length) + footerText;
                    generatedFileNames.Add(fileName);
                    CreateFile(fileName, content);
                    template.Remove(block.Start, block.Length);
                }
            }
        }

        protected virtual void CreateFile(String fileName, String content)
        {
            if (IsFileContentDifferent(fileName, content))
                File.WriteAllText(fileName, content);
        }

        public virtual String GetCustomToolNamespace(String fileName)
        {
            return null;
        }

        public virtual String DefaultProjectNamespace
        {
            get { return null; }
        }

        protected bool IsFileContentDifferent(String fileName, String newContent)
        {
            return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
        }

        private Manager(ITextTemplatingEngineHost host, StringBuilder template)
        {
            this.host = host;
            this.template = template;
        }

        private Block CurrentBlock
        {
            get { return currentBlock; }
            set
            {
                if (CurrentBlock != null)
                    EndBlock();
                if (value != null)
                    value.Start = template.Length;
                currentBlock = value;
            }
        }

        private class VSManager : Manager
        {
            private EnvDTE.ProjectItem templateProjectItem;
            private EnvDTE.DTE dte;
            private Action<String> checkOutAction;
            private Action<IEnumerable<String>> projectSyncAction;
            private IVsQueryEditQuerySave2 queryEditSave;

            public override String DefaultProjectNamespace
            {
                get
                {
                    return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
                }
            }

            public override String GetCustomToolNamespace(string fileName)
            {
                return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
            }

            public override void Process(bool split)
            {
                if (templateProjectItem.ProjectItems == null)
                    return;
                base.Process(split);
                projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
            }

            public override bool FileOkToWrite(String fileName)
            {
                CheckoutFileIfRequired(fileName);
                return base.FileOkToWrite(fileName);
            }

            protected override void CreateFile(String fileName, String content)
            {
                if (IsFileContentDifferent(fileName, content))
                {
                    CheckoutFileIfRequired(fileName);
                    File.WriteAllText(fileName, content);
                }
            }

            internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
                : base(host, template)
            {
                var hostServiceProvider = (IServiceProvider)host;
                if (hostServiceProvider == null)
                    throw new ArgumentNullException("Could not obtain IServiceProvider");
                dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
                if (dte == null)
                    throw new ArgumentNullException("Could not obtain DTE from host");
                templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
                checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
                projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
                queryEditSave = (IVsQueryEditQuerySave2)hostServiceProvider.GetService(typeof(SVsQueryEditQuerySave));
            }

            private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames)
            {
                var keepFileNameSet = new HashSet<String>(keepFileNames);
                var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
                var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
                foreach (EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
                    projectFiles.Add(projectItem.get_FileNames(0), projectItem);

                // Remove unused items from the project
                foreach (var pair in projectFiles)
                    if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                        pair.Value.Delete();

                // Add missing files to the project
                foreach (String fileName in keepFileNameSet)
                    if (!projectFiles.ContainsKey(fileName))
                        templateProjectItem.ProjectItems.AddFromFile(fileName);
            }

            private void CheckoutFileIfRequired(String fileName)
            {
                if (queryEditSave != null)
                {
                    uint pfEditVerdict;
                    queryEditSave.QuerySaveFile(fileName, 0, null, out pfEditVerdict);
                }
                   else
                {
                    var sc = dte.SourceControl;
                    if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName)) 
                        checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
                }
            }
        }
    }

/*
    End of Manager.tt
*/
#>